Hexagonal Grids
from Red Blob Games
Home
Blog
Links
Twitter
About
Search
Mar 2013, updated in Mar 2015, Apr 2018, Feb 2019
This guide will cover various ways to make hexagonal grids, the relationships between different approaches, and common formulas and algorithms. Hexagonal grids aren't as common as square grids. I've been collecting hex grid resources for over 20 years, and wrote this guide to the most elegant approaches that lead to the simplest code, largely based on the guides by Charles Fu and Clark Verbrugge. Most parts of this page are interactive.
Angles, size, spacing
Coordinate systems
Conversions
Neighbors
Distances
Line drawing
Range
Rotation
Rings
Field of view
Hex to pixel
Pixel to hex
Rounding
Map storage
Wraparound maps
Pathfinding
More reading
The code samples on this page are written in pseudo-code; they're meant to be easy to read and understand. The implementation guide has code in C++, Javascript, C#, Python, Java, Typescript, and more.

Geometry#
Hexagons are 6-sided polygons. Regular hexagons have all the sides the same length. I'll assume all the hexagons we're working with here are regular. The typical orientations for hex grids are vertical columns (flat topped) and horizontal rows (pointy topped).

Hexagons have 6 sides and 6 corners. Each side is shared by 2 hexagons. Each corner is shared by 3 hexagons. For more about centers, sides, and corners, see my article on grid parts (squares, hexagons, and triangles).

Angles#
In a regular hexagon the interior angles are 120°. There are six “wedges”, each an equilateral triangle with 60° angles inside. Each corner is size units away from the center. In code:

function flat_hex_corner(center, size, i):
    var angle_deg = 60 * i
    var angle_rad = PI / 180 * angle_deg
    return Point(center.x + size * cos(angle_rad),
                 center.y + size * sin(angle_rad))
To fill a hexagon, gather the polygon vertices at hex_corner(…, 0) through hex_corner(…, 5). To draw a hexagon outline, use those vertices, and then draw a line back to hex_corner(…, 0).

The difference between the two orientations is a rotation, and that causes the angles to change: flat topped angles are 0°, 60°, 120°, 180°, 240°, 300° and pointy topped angles are 30°, 90°, 150°, 210°, 270°, 330°. Note that the diagrams on this page use the y axis pointing down (angles increase clockwise); you may have to make some adjustments if your y axis points up (angles increase counterclockwise).

Size and Spacing#
Next we want to put several hexagons together. In the flat orientation, a hexagon has width w = 2 * size and height h = sqrt(3) * size. The sqrt(3) comes from sin(60°).

The horizontal distance between adjacent hexagon centers is w * 3/4. The vertical distance between adjacent hexagon centers is h.

Some games use pixel art for hexagons that does not match an exactly regular polygon. The angles and spacing formulas I describe in this section won't match the sizes of your hexagons. The rest of the article, describing algorithms on hex grids, will work even if your hexagons are stretched or shrunk a bit, and I explain on the implementation page how to handle stretching.

Coordinate Systems#
Now let's assemble hexagons into a grid. With square grids, there's one obvious way to do it. With hexagons, there are multiple approaches. I like cube coordinates for algorithms and axial or doubled for storage.

Offset coordinates#
The most common approach is to offset every other column or row. Columns are named col (q). Rows are named row (r). You can either offset the odd or the even column/rows, so the horizontal and vertical hexagons each have two variants.

“odd-r” horizontal layout
shoves odd rows right
“even-r” horizontal layout
shoves even rows right
“odd-q” vertical layout
shoves odd columns down
“even-q” vertical layout
shoves even columns down
Cube coordinates#
Another way to look at hexagonal grids is to see that there are three primary axes, unlike the two we have for square grids. There's an elegant symmetry with these.

Let's take a cube grid and slice out a diagonal plane at x + y + z = 0. This is a weird idea but it helps us make hex grid algorithms simpler. In particular, we can reuse standard operations from cartesian coordinates: adding coordinates, subtracting coordinates, multiplying or dividing by a scalar, and distances.

Notice the three six hex grid directions are halfway between two of the cube axes. We'll see this in the neighbors section, where moving along one of the six hex grid directions involves changing two of the coordinates.

Because we already have algorithms for square and cube grids, using cube coordinates allows us to adapt those algorithms to hex grids. I will be using this system for most of the algorithms on the page. To use the algorithms with another coordinate system, I'll convert to cube coordinates, run the algorithm, and convert back.


Switch to hexagons
Study how the cube coordinates work on the hex grid. Selecting the hexes will highlight the cube coordinates corresponding to the three axes.
Each direction on the cube grid corresponds to a line on the hex grid. Try highlighting a hex with z at 0, 1, 2, 3 to see how these are related. The row is marked in blue. Try the same for x (green) and y (purple).
Each direction on the hex grid is a combination of two directions on the cube grid. For example, northwest on the hex grid lies between the +y and -z, so every step northwest involves adding 1 to y and subtracting 1 from z.
The cube coordinates are a reasonable choice for a hex grid coordinate system. The constraint is that x + y + z = 0 so the algorithms must preserve that. The constraint also ensures that there's a canonical coordinate for each hex.

There are many different valid cube hex coordinate systems. Some of them have constraints other than x + y + z = 0. I've shown only one of the many systems. You can also construct cube coordinates with x-y, y-z, z-x, and that has its own set of interesting properties, which I don't explore here.

"But Amit!" you say, "I don't want to store 3 numbers for coordinates. I don't know how to store a map that way."

Axial coordinates#
The axial coordinate system, sometimes called “trapezoidal” or “oblique” or “skewed”, is built by taking two of the three coordinates from a cube coordinate system. Since we have a constraint x + y + z = 0, there's some redundancy, and we don't need to store all three coordinates. This diagram is the same as the previous one, except I don't show y:

There are many choices of cube coordinate system, and many choices of axial coordinate system. I'm not going to show all of the combinations in this guide. I've chosen q for "column" = x and r as "row" = z. This choice is arbitary, as you can rotate and flip the diagrams to make many different assignments of ±x,±y,±z to q,r.

The advantage of this system over offset grids is that the algorithms are cleaner when you can use add, subtract, multiply, and divide on hex coordinates. The disadvantage of this system is that storing a rectangular map is a little weird; see the map storage section for ways to handle that. In my projects, I name the axes q, r, s so that I have the constraint q + r + s = 0, and then I can calculate s = -q - r when I need the third coordinate for algorithms that work better with cube coordinates.

Doubled coordinates#
Although I recommend axial/cube coordinates, if you are sticking to offset coordinates, consider the doubled variant. It makes many of the algorithms easier to implement. Instead of alternation, the doubled coordinates double either the horizontal or vertical step size. It has a constraint (col + row) % 2 == 0. In the horizontal (pointy top hex) layout it increases the column by 2 each hex; in the vertical (flat top hex) layout it increases the row by 2 each hex. This allows the in-between values for the hexes that are halfway in between:
“double-width” horizontal layout
doubles column values
“double-height” horizontal layout
doubles row values
I haven't found much information about this system — tri-bit.com called it interlaced, rot.js calls it double width, and this paper calls it rectangular. Other possible names: brick or checkerboard. I'm not sure what to call it. Tamas Kenez sent me the core algorithms (neighbors, distances, etc.). If you have any references, please send them to me.
Comparison#
What do I recommend?

Offset	Doubled	Axial	Cube
Pointy rotation	evenr, oddr	doublewidth	axial	cube
Flat rotation	evenq, oddq	doubleheight
Other rotations	no	yes
Vector operations (add, subtract, scale)	no	yes	yes	yes
Array storage	rectangular	no*	rhombus*	no*
Hash storage	any shape	any shape
Hexagonal symmetry	no	no	no	yes
Easy algorithms	few	some	most	all
* rectangular maps require an adapter, shown in the map storage section

My recommendation: if you are only going to use rectangular maps, and never rotate the map, consider the doubled or offset coordinates, as they will line up with your map better than axial or cube. In all other cases, use axial as the primary system, and calculate the third cube coordinate only for those algorithms where cube is easier to work with.

Coordinate conversion#
It is likely that you will use axial or offset coordinates in your project, but many algorithms are simpler to express in cube coordinates. Therefore you need to be able to convert back and forth.

Axial coordinates#
Axial coordinates are closely connected to cube coordinates. Axial discards the third coordinate. Cube calculates the third coordinate from the other two.
function cube_to_axial(cube):
    var q = cube.x
    var r = cube.z
    return Hex(q, r)

function axial_to_cube(hex):
    var x = hex.q
    var z = hex.r
    var y = -x-z
    return Cube(x, y, z)
Offset coordinates#
Determine which type of offset system you use; *-r are pointy top; *-q are flat top. The conversion is different for each.function cube_to_oddq(cube):
    var col = cube.x
    var row = cube.z + (cube.x - (cube.x&1)) / 2
    return OffsetCoord(col, row)

function oddq_to_cube(hex):
    var x = hex.col
    var z = hex.row - (hex.col - (hex.col&1)) / 2
    var y = -x-z
    return Cube(x, y, z)
 odd-r  shoves odd rows by +? column
 even-r  shoves even rows by +? column
 odd-q  shoves odd columns by +? row
 even-q  shoves even columns by +? row
Implementation note: I use a&1 (bitwise and) instead of a%2 (modulo) to detect whether something is even (0) or odd (1), because it works with negative numbers too. See a longer explanation on my implementation notes page.
Doubled coordinates#
function doubleheight_to_cube(hex):
    var x = hex.col
    var z = (hex.row - hex.col) / 2
    var y = -x-z
    return Cube(x, y, z)

function cube_to_doubleheight(cube):
    var col = cube.x
    var row = 2 * cube.z + cube.x
    return DoubledCoord(col, row)

function doublewidth_to_cube(hex):
    var x = (hex.col - hex.row) / 2
    var z = hex.row
    var y = -x-z
    return Cube(x, y, z)

function cube_to_doublewidth(cube):
    var col = 2 * cube.x + cube.z
    var row = cube.z
    return DoubledCoord(col, row)
It may also be useful to define conversion to/from offset coordinates.

Neighbors#
Given a hex, which 6 hexes are neighboring it? As you might expect, the answer is simplest with cube coordinates, still pretty simple with axial coordinates, and slightly trickier with offset coordinates. We might also want to calculate the 6 “diagonal” hexes.

Cube coordinates#
Moving one space in hex coordinates involves changing one of the 3 cube coordinates by +1 and changing another one by -1 (the sum must remain 0). There are 3 possible coordinates to change by +1, and 2 remaining that could be changed by -1. This results in 6 possible changes. Each corresponds to one of the hexagonal directions. The simplest and fastest approach is to precompute the permutations and put them into a table of Cube(dx, dy, dz) at compile time:

var cube_directions = [
    Cube(+1, -1, 0), Cube(+1, 0, -1), Cube(0, +1, -1), 
    Cube(-1, +1, 0), Cube(-1, 0, +1), Cube(0, -1, +1), 
]

function cube_direction(direction):
    return cube_directions[direction]

function cube_neighbor(cube, direction):
    return cube_add(cube, cube_direction(direction))
Axial coordinates#
As before, we'll use the cube system as a starting point. Take the table of Cube(dx, dy, dz) and convert into a table of Hex(dq, dr):

var axial_directions = [
    Hex(+1, 0), Hex(+1, -1), Hex(0, -1), 
    Hex(-1, 0), Hex(-1, +1), Hex(0, +1), 
]

function hex_direction(direction):
    return axial_directions[direction]

function hex_neighbor(hex, direction):
    var dir = hex_direction(direction)
    return Hex(hex.q + dir.q, hex.r + dir.r)
Offset coordinates#
With offset coordinates, the change depends on where in the grid we are. If we're on an offset column/row then the rule is different than if we're on a non-offset column/row.

As above, we'll build a table of the numbers we need to add to col and row. However offset coordinates can't be safely added and subtracted. Instead, the results are different for odd and even columns/rows, so we will need two separate lists of neighbors. Look at (1,1) on the grid map above and see how col and row change as you move in each of the six directions. Then do this again for (2,2). The tables and code are different for each of the four offset grid types, so pick a grid type to see the corresponding code.

var oddr_directions = [
    [[+1,  0], [ 0, -1], [-1, -1], 
     [-1,  0], [-1, +1], [ 0, +1]],
    [[+1,  0], [+1, -1], [ 0, -1], 
     [-1,  0], [ 0, +1], [+1, +1]],
]

function oddr_offset_neighbor(hex, direction):
    var parity = hex.row & 1
    var dir = oddr_directions[parity][direction]
    return OffsetCoord(hex.col + dir[0], hex.row + dir[1])Pick a grid type:  odd-r  even-r  odd-q  even-q 
Using the above lookup tables is the easiest way to to calculate neighbors. It's also possible to derive these numbers, for those of you who are curious.

Doubled coordinates#
Unlike offset coordinates, the neighbors for doubled coordinates do not depend on which column/row we're on. They're the same everywhere, like axial and cube coordinates. Also unlike offset coordinates, we can safely add and subtract doubled coordinates, which makes them easier to work with than offset coordinates.

var doublewidth_directions = [
    [+2,  0], [+1, -1], [-1, -1], 
    [-2,  0], [-1, +1], [+1, +1], 
]

function doublewidth_neighbor(hex, direction):
    var dir = doublewidth_directions[direction]
    return DoubledCoord(hex.col + dir.col, hex.col + dir.col)Pick a grid type:  double width  double height 
Diagonals#
Moving to a “diagonal” space in hex coordinates changes one of the 3 cube coordinates by ±2 and the other two by ?1 (the sum must remain 0).

var cube_diagonals = [
    Cube(+2, -1, -1), Cube(+1, +1, -2), Cube(-1, +2, -1), 
    Cube(-2, +1, +1), Cube(-1, -1, +2), Cube(+1, -2, +1), 
]

function cube_diagonal_neighbor(cube, direction):
    return cube_add(cube, cube_diagonals[direction])
As before, you can convert these into axial by dropping one of the three coordinates, or convert to offset/doubled by precalculating the results.

Distances#
Cube coordinates#
In the cube coordinate system, each hexagon is a cube in 3d space. Adjacent hexagons are distance 1 apart in the hex grid but distance 2 apart in the cube grid. This makes distances simple. In a square grid, Manhattan distances are abs(dx) + abs(dy). In a cube grid, Manhattan distances are abs(dx) + abs(dy) + abs(dz). The distance on a hex grid is half that:

function cube_distance(a, b):
    return (abs(a.x - b.x) + abs(a.y - b.y) + abs(a.z - b.z)) / 2
An equivalent way to write this is by noting that one of the three coordinates must be the sum of the other two, then picking that one as the distance. You may prefer the “divide by two” form above, or the “max” form here, but they give the same result:

function cube_distance(a, b):
    return max(abs(a.x - b.x), abs(a.y - b.y), abs(a.z - b.z))
The maximum of the three coordinates is the distance. You can also use the max of abs(dx-dy), abs(dy-dz), abs(dz-dx) to figure out which of the 6 “wedges” a hex is in; see diagrams here.

Xiangguo Li's paper Storage and addressing scheme for practical hexagonal image processing. (DOI) gives a formula for Euclidean distance, which can be adapted to axial coordinates: sqrt(dq? + dr? + dq*dr).
Axial coordinates#
In the axial system, the third coordinate is implicit. Let's convert axial to cube to calculate distance:

function hex_distance(a, b):
    var ac = axial_to_cube(a)
    var bc = axial_to_cube(b)
    return cube_distance(ac, bc)
If your compiler inlines axial_to_cube and cube_distance, it will generate this code:

function hex_distance(a, b):
    return (abs(a.q - b.q) 
          + abs(a.q + a.r - b.q - b.r)
          + abs(a.r - b.r)) / 2
There are lots of different ways to write hex distance in axial coordinates, but no matter which way you write it, axial hex distance is derived from the Mahattan distance on cubes. For example, the “difference of differences” described here results from writing a.q + a.r - b.q - b.r as a.q - b.q + a.r - b.r, and using “max” form instead of the “divide by two” form of cube_distance. They're all equivalent once you see the connection to cube coordinates.

Offset coordinates#
As with axial coordinates, we'll convert offset coordinates to cube coordinates, then use cube distance.

function offset_distance(a, b):
    var ac = offset_to_cube(a)
    var bc = offset_to_cube(b)
    return cube_distance(ac, bc)
We'll use the same pattern for many of the algorithms: convert hex to cube, run the cube version of the algorithm, and convert any cube results back to hex coordinates (whether axial or offset). There are also more direct formulas for distances; see the rot.js manual for a formula in the "Odd shift" section.

Doubled coordinates#
Although converting doubled coordinates to cube coordinates works, there's also a direct formula for distances, from the rot.js manual:

function doublewidth_distance(a, b):
    var dx = abs(a.col - b.col)
    var dy = abs(a.row - b.row)
    return dy + max(0, (dx-dy)/2)

function doubleheight_distance(a, b):
    var dx = abs(a.col - b.col)
    var dy = abs(a.row - b.row)
    return dx + max(0, (dy?dx)/2)
Line drawing#
How do we draw a line from one hex to another? I use linear interpolation for line drawing. Evenly sample the line at N+1 points, and figure out which hexes those samples are in.
First we calculate N=8 to be the hex distance between the endpoints.
Then evenly sample N+1 points between point A and point B. Using linear interpolation, each point will be A + (B - A) * 1.0/N * i, for values of i from 0 to N, inclusive. In the diagram these sample points are the dark blue dots. This results in floating point coordinates.
Convert each sample point (float) back into a hex (int). The algorithm is called cube_round.
Putting these together to draw a line from A to B:function lerp(a, b, t): # for floats
    return a + (b - a) * t

function cube_lerp(a, b, t): # for hexes
    return Cube(lerp(a.x, b.x, t), 
                lerp(a.y, b.y, t),
                lerp(a.z, b.z, t))

function cube_linedraw(a, b):
    var N = cube_distance(a, b)
    var results = []
    for each 0 ? i ? N:
        results.append(cube_round(cube_lerp(a, b, 1.0/N * i)))
    return resultsMore notes:
There are times when cube_lerp will return a point that's exactly on the side between two hexes. Then cube_round will push it one way or the other. The lines will look better if it's always pushed in the same direction. You can do this by adding an "epsilon" hex Cube(1e-6, 2e-6, -3e-6) to one or both of the endpoints before starting the loop. This will "nudge" the line in one direction to avoid landing on side boundaries.
The DDA Algorithm on square grids sets N to the max of the distance along each axis. We do the same in cube space, which happens to be the same as the hex grid distance.
There are times when this algorithm slightly goes outside the marked hexagons. I haven't come up with an easy fix for this.
The cube_lerp function needs to return a cube with float coordinates. If you're working in a statically typed language, you won't be able to use the Cube type but instead could define FloatCube, or inline the function into the line drawing code if you want to avoid defining another type.
You can optimize the code by inlining cube_lerp, and then calculating B.x-A.x, B.x-A.y, and 1.0/N outside the loop. Multiplication can be turned into repeated addition. You'll end up with something like the DDA algorithm.
I use axial or cube coordinates for line drawing, but if you want something for offset coordinates, take a look at this article.
There are many variants of line drawing. Sometimes you'll want "super cover". Someone sent me hex super cover line drawing code but I haven't studied it yet.
A paper from Yong-Kui, Liu, The Generation of Straight Lines on Hexagonal Grids, Computer Graphics Forum 12-1 (Feb 1993) (DOI), describes a variant of Bresenham's line drawing algorithm for hexagonal grids.
Movement Range#
Coordinate range#
Given a hex center and a range N, which hexes are within N steps from it?

We can work backwards from the hex distance formula, distance = max(abs(x), abs(y), abs(z)). To find all hexes within N steps, we need max(abs(x), abs(y), abs(z)) ? N. This means we need all three to be true: abs(x) ? N and abs(y) ? N and abs(z) ? N. Removing absolute value, we get -N ? x ? +N and -N ? y ? +N and -N ? z ? +N. In code it's a nested loop:

var results = []
for each -N ? x ? +N:
    for each -N ? y ? +N:
        for each -N ? z ? +N:
            if x + y + z = 0:
                results.append(cube_add(center, Cube(x, y, z)))
This loop will work but it's somewhat inefficient. Of all the values of z we loop over, only one of them actually satisfies the x + y + z = 0 constraint on cubes. Instead, let's directly calculate the value of z that satisfies the constraint:

var results = []
for each -N ? x ? +N:
    for each max(-N, -x-N) ? y ? min(+N, -x+N):
        var z = -x-y
        results.append(cube_add(center, Cube(x, y, z)))
This loop iterates over exactly the needed coordinates. In the diagram, each range is a pair of lines. Each line is an inequality (a half-plane). We pick all the hexes that satisfy all six inequalities.

Intersecting ranges#
If you need to find hexes that are in more than one range, you can intersect the ranges before generating a list of hexes.

You can either think of this problem algebraically or geometrically. Algebraically, each hexagonally-shaped region is expressed as inequality constraints of the form -N ? dx ? +N, and we're going to solve for the intersection of those constraints. Geometrically, each region is a cube in 3D space, and we're going to intersect two cubes in 3D space to form a cuboid in 3D space, then project back to the x + y + z = 0 plane to get hexes. I'm going to solve it algebraically:

First, we rewrite constraint -N ? dx ? +N into a more general form, xmin ? x ? xmax, and set xmin = center.x - N and xmax = center.x + N. We'll do the same for y and z, and end up with this generalization of the code from the previous section:

var results = []
for each xmin ? x ? xmax:
    for each max(ymin, -x-zmax) ? y ? min(ymax, -x-zmin):
        var z = -x-y
        results.append(Cube(x, y, z))
The intersection of two ranges a ? x ? b and c ? x ? d is max(a, c) ? x ? min(b, d). Since a hex region is expressed as ranges over x, y, z, we can separately intersect each of the x, y, z ranges then use the nested loop to generate a list of hexes in the intersection. For one hex region we set xmin = H.x - N and xmax = H.x + N and likewise for y and z. For intersecting two hex regions we set xmin = max(H1.x - N, H2.x - N) and xmax = min(H1.x + N, H2.x + N), and likewise for y and z. The same pattern works for intersecting three or more regions, and can generalize to other shapes (triangles, trapezoids, rhombuses, non-regular hexagons).

Obstacles#
If there are obstacles, the simplest thing to do is a distance-limited flood fill (breadth first search). In this diagram, the limit is set to moves. In the code, fringes[k] is an array of all hexes that can be reached in k steps. Each time through the main loop, we expand level k-1 into level k. This works equally well with any of the hex coordinate systems (cube, axial, offset, doubled).

function hex_reachable(start, movement):
    var visited = set() # set of hexes
    add start to visited
    var fringes = [] # array of arrays of hexes
    fringes.append([start])

    for each 1 < k ? movement:
        fringes.append([])
        for each hex in fringes[k-1]:
            for each 0 ? dir < 6:
                var neighbor = hex_neighbor(hex, dir)
                if neighbor not in visited and not blocked:
                    add neighbor to visited
                    fringes[k].append(neighbor)

    return visited

Limit movement = 4
Rotation#
Given a hex vector (difference between one hex and another), we might want to rotate it to point to a different hex. This is simple with cube coordinates if we stick with rotations of 1/6th of a circle.

A rotation 60° right shoves each coordinate one slot to the right:

          [ x,  y,  z]
to    [-z, -x, -y]
to [y,  z,  x]
A rotation 60° left shoves each coordinate one slot to the left:

      [ x,  y,  z]
to        [-y, -z, -x]
to           [  z,  x,  y]
As you play with diagram, notice that each 60° rotation flips the signs and also physically “rotates” the coordinates. Take a look at the axis legend on the bottom left to see how this works. After a 120° rotation the signs are flipped back to where they were. A 180° rotation flips the signs but the coordinates have rotated back to where they originally were.

Here's the full recipe for rotating a position P around a center position C to result in a new position R:

Convert positions P and C to cube coordinates.
Calculate a vector by subtracting the center: P_from_C = P - C = Cube(P.x - C.x, P.y - C.y, P.z - C.z).
Rotate the vector P_from_C as described above, and call the resulting vector R_from_C.
Convert the vector back to a position by adding the center: R = R_from_C + C = Cube(R_from_C.x + C.x, R_from_C.y + C.y, R_from_C.z + C.z).
Convert the cube position R back to to your preferred coordinate system.
It's several conversion steps but each step is simple. You can shortcut some of these steps by defining rotation directly on axial coordinates, but hex vectors don't work for offset coordinates and I don't know a shortcut for offset coordinates. Also see this stackexchange discussion for other ways to calculate rotation.

Rings#
Single ring#
To find out whether a given hex is on a ring of a given radius, calculate the distance from that hex to the center and see if it's radius. To get a list of all such hexes, take radius steps away from the center, then follow the rotated vectors in a path around the ring.

function cube_ring(center, radius):
    var results = []
    # this code doesn't work for radius == 0; can you see why?
    var cube = cube_add(center, 
                        cube_scale(cube_direction(4), radius))
    for each 0 ? i < 6:
        for each 0 ? j < radius:
            results.append(cube)
            cube = cube_neighbor(cube, i)
    return results
In this code, cube starts out on the ring, shown by the large arrow from the center to the corner in the diagram. I chose corner 4 to start with because it lines up the way my direction numbers work but you may need a different starting corner. At each step of the inner loop, cube moves one hex along the ring. After 6 * radius steps it ends up back where it started.

The scale, add, and neighbor operations also work on axial and doubled coordinates, so the same algorithm can be used. For offset coordinates, convert to one of the other formats, generate the ring, and convert back.
Spiral rings#
Traversing the rings one by one in a spiral pattern, we can fill in the interior:

function cube_spiral(center, radius):
    var results = [center]
    for each 1 ? k ? radius:
        results = results + cube_ring(center, k)
    return results
The area of the larger hexagon will be the sum of the circumferences, plus 1 for the center; use this formula to help you calculate the area.Visiting the hexes this way can also be used to calculate movement range.
Field of view#
Given a location and a distance, what is visible from that location, not blocked by obstacles? The simplest way to do this is to draw a line to every hex that's in range. If the line doesn't hit any walls, then you can see the hex. Mouse over a hex to see the line being drawn to that hex, and which walls it hits.

This algorithm can be slow for large areas but it's so easy to implement that it's what I recommend starting with.

There are many different ways to define what's "visible". Do you want to be able to see the center of the other hex from the center of the starting hex? Do you want to see any part of the other hex from the center of the starting point? Maybe any part of the other hex from any part of the starting point? Are there obstacles that occupy less than a complete hex? Field of view turns out to be trickier and more varied than it might seem at first. Start with the simplest algorithm, but expect that it may not compute exactly the answer you want for your project. There are even situations where the simple algorithm produces results that are illogical.Clark Verbrugge's guide describes a “start at center and move outwards” algorithm to calculate field of view. Also see the Duelo project, which has an an online demo of directional field of view and code on Github. Also see my article on 2d visibility calculation for an algorithm that works on polygons, including hexagons. For grids, the roguelike community has a nice set of algorithms for square grids (see this and this and this); some of them might be adapted for hex grids.
Hex to pixel#
For hex to pixel, it's useful to review the size and spacing diagram at the top of the page.

Axial coordinates#
For axial coordinates, the way to think about hex to pixel conversion is to look at the basis vectors. The arrow (0,0)>(1,0) is the q basis vector (x=sqrt(3), y=0) and (0,0)>(0,1) is the r basis vector (x=sqrt(3)/2, y=3/2). The pixel coordinate is q_basis * q + r_basis * r. For example, the hex at (1,1) is the sum of 1 q vector and 1 r vector. A hex at (3,2) would be the sum of 3 q vectors and 2 r vectors.
The code for flat top or pointy top is:function pointy_hex_to_pixel(hex):
    var x = size * (sqrt(3) * hex.q  +  sqrt(3)/2 * hex.r)
    var y = size * (                         3./2 * hex.r)
    return Point(x, y)This can also be viewed as a matrix multiply, where the basis vectors are the columns of the matrix:?x?            ? sqrt(3)   sqrt(3)/2 ?   ?q?
? ?  =  size ? ?                     ? ? ? ?
?y?            ?    0          3/2   ?   ?r?The matrix approach will come in handy later when we want to convert pixel coordinates back to hex coordinates. To invert the process of hex-to-pixel into a pixel-to-hex process, we will invert the hex-to-pixel matrix into a pixel-to-hex matrix.
Offset coordinates#
For offset coordinates, we need to offset either the column or row number (it will no longer be an integer).

function oddr_offset_to_pixel(hex):
    var x = size * sqrt(3) * (hex.col + 0.5 * (hex.row&1))
    var y = size * 3/2 * hex.row
    return Point(x, y)
Offset coordinates:   odd-r  even-r  odd-q  even-q 
Unfortunately offset coordinates don't have basis vectors that we can use with a matrix. This is one reason pixel-to-hex conversions are harder with offset coordinates.

Another approach is to convert the offset coordinates into cube/axial coordinates, then use the cube/axial to pixel conversion. By inlining the conversion code then optimizing, it will end up being the same as above.

Doubled coordinates#
Doubled makes many algorithms simpler than offset.

function doublewidth_to_pixel(hex):
    var x = size * sqrt(3)/2 * hex.col
    var y = size * 3/2 * hex.row
    return Point(x, y)

function doubleheight_to_pixel(hex):
    var x = size * 3/2 * hex.col
    var y = size * sqrt(3)/2 * hex.row
    return Point(x, y)
Pixel to Hex#
One of the most common questions is, how do I take a pixel location (such as a mouse click) and convert it into a hex grid coordinate? I'll show how to do this for axial or cube coordinates. For offset coordinates, the simplest thing to do is to convert the cube to offset at the end.
First we invert the hex to pixel conversion. This will give us a fractional hex coordinate, shown as a small red circle in the diagram.
Then we find the hex containing the fractional hex coordinate, shown as the highlighted hex in the diagram.
To convert from hex coordinates to pixel coordinates, we multiplied q, r by basis vectors to get x, y. This was a matrix multiply:
?x?            ? sqrt(3)   sqrt(3)/2 ?   ?q?
? ?  =  size ? ?                     ? ? ? ?
?y?            ?    0          3/2   ?   ?r?
Matrix for: flat top or pointy top

To invert the hex-to-pixel process into a pixel-to-hex process we invert the pointy-top hex-to-pixel matrix into a pixel-to-hex matrix:?q?     ? sqrt(3)/3     -1/3 ?   ?x?
? ?  =  ?                    ? ? ? ? ? size
?r?     ?     0          2/3 ?   ?y?This calculation will give us fractional axial coordinates (floats) for q and r. The hex_round() function will convert the fractional axial coordinates into integer axial hex coordinates. Here's the code:function pixel_to_pointy_hex(point):
    var q = (sqrt(3)/3 * point.x  -  1./3 * point.y) / size
    var r = (                        2./3 * point.y) / size
    return hex_round(Hex(q, r))Code for: flat top or pointy topThat's three lines of code to convert a pixel location into an axial hex coordinate. If you use offset coordinates, use return cube_to_{odd,even}{r,q}(cube_round(Cube(q, -q-r, r))).There are many other ways to convert pixel to hex; see this page for the ones I know of.
Rounding to nearest hex#
Sometimes we'll end up with a floating-point cube coordinate (x, y, z), and we'll want to know which hex it should be in. This comes up in line drawing and pixel to hex. Converting a floating point value to an integer value is called rounding so I call this algorithm cube_round.

With cube coordinates, x + y + z = 0, even with floating point cube coordinates. So let's round each component to the nearest integer, (rx, ry, rz). However, although x + y + z = 0, after rounding we do not have a guarantee that rx + ry + rz = 0. So we reset the component with the largest change back to what the constraint rx + ry + rz = 0 requires. For example, if the y-change abs(ry-y) is larger than abs(rx-x) and abs(rz-z), then we reset ry = -rx-rz. This guarantees that rx + ry + rz = 0. Here's the algorithm:

function cube_round(cube):
    var rx = round(cube.x)
    var ry = round(cube.y)
    var rz = round(cube.z)

    var x_diff = abs(rx - cube.x)
    var y_diff = abs(ry - cube.y)
    var z_diff = abs(rz - cube.z)

    if x_diff > y_diff and x_diff > z_diff:
        rx = -ry-rz
    else if y_diff > z_diff:
        ry = -rx-rz
    else:
        rz = -rx-ry

    return Cube(rx, ry, rz)
For non-cube coordinates, the simplest thing to do is to convert to cube coordinates, use the rounding algorithm, then convert back:

function hex_round(hex):
    return cube_to_axial(cube_round(axial_to_cube(hex)))
The same would work if you have oddr, evenr, oddq, or evenq instead of axial.

Implementation note: cube_round and hex_round take float coordinates instead of int coordinates. If you've written a Cube and Hex class, they'll work fine in dynamically typed languages where you can pass in floats instead of ints, and they'll also work fine in statically typed languages with a unified number type. However, in most statically typed languages, you'll need a separate class/struct type for float coordinates, and cube_round will have type FloatCube > Cube. If you also need hex_round, it will be FloatHex > Hex, using helper function floatcube_to_floathex instead of cube_to_hex. In languages with parameterized types (C++, Haskell, etc.) you might define Cube<T> where T is either int or float. Alternatively, you could write cube_round to take three floats as inputs instead of defining a new type just for this function.

Map storage in axial coordinates#
One of the common complaints about the axial coordinate system is that it leads to wasted space when using a rectangular map; that's one reason to favor an offset coordinate system. However all the hex coordinate systems lead to wasted space when using a triangular or hexagonal map. We can use the same strategies for storing all of them.

Shape: rectangle hexagon rhombus down-triangle up-triangle 
Switch to array of arrays
Notice in the diagram that the wasted space is on the left and right sides of each row (except for rhombus maps) This gives us three strategies for storing the map:

Use a 2D Array. Use nulls or some other sentinel at the unused spaces. Store Hex(q, r) at array[r][q]. At most there's a factor of two for these common shapes; it may not be worth using a more complicated solution.
Use a hash table instead of dense array. This allows arbitrarily shaped maps, including ones with holes. Store Hex(q, r) in hash_table(hash(q,r)).
Use an array of arrays by sliding row to the left, and shrinking the rows to the minimum size. For pointy-topped hexes, store Hex(q, r) in array[r - first_row][q - first_column(r)]. Some examples for the map shapes above:
Rectangle. Store Hex(q, r) at array[r][q + floor(r/2)]. Each row has the same length. This is equivalent to odd-r offset.
Hexagon. Store Hex(q, r) at array[r][q - max(0, N-r)]. Row r size is 2*N+1 - abs(N-r).
Rhombus. Conveniently, first_row and first_column(r) are both 0. Store Hex(q, r) at array[r][q]. All rows are the same length.
Down-triangle. Store Hex(q, r) at array[r][q]. Row r has size N+1-r.
Up-triangle. Store Hex(q, r) at array[r][q - N+1+r]. Row r has size 1+r.
For flat-topped hexes, swap the roles of the rows and columns, and use array[q - first_column][r - first_row(q)].
Encapsulate access into the getter/setter in a map class so that the rest of the game doesn't need to know about the map storage. Your maps may not look exactly like these, so you will have to adapt one of these approaches.

Wraparound maps#
In some games you want the map to “wrap” around the edges. In a square map, you can either wrap around the x-axis only (roughly corresponding to a sphere) or both x- and y-axes (roughly corresponding to a torus). Wraparound depends on the map shape, not the tile shape. To wrap around a rectangular map is easy with offset coordinates. I'll show how to wrap around a hexagon-shaped map with cube coordinates.

Corresponding to the center of the map, there are six “mirror” centers. When you go off the map, you subtract the mirror center closest to you until you are back on the main map. In the diagram, try exiting the center map, and watch one of the mirrors enter the map on the opposite side.

The simplest implementation is to precompute the answers. Make a lookup table storing, for each hex just off the map, the corresponding cube on the other side. For each of the six mirror centers M, and each of the locations on the map L, store mirror_table[cube_add(M, L)] = L. Then any time you calculate a hex that's in the mirror table, replace it by the unmirrored version. See stackoverflow for another approach.

For a hexagonal shaped map with radius N, the mirror centers will be Cube(2*N+1, -N, -N-1) and its six rotations.

Related: Sander Evers has a nice explanation of how to combine small hexagons into a grid of large hexagons and also a coordinate system to represent small hexagons within a larger one.
Pathfinding#
If you're using graph-based pathfinding such as A* or Dijkstra's algorithm or Floyd-Warshall, pathfinding on hex grids isn't different from pathfinding on square grids. The explanations and code from my pathfinding tutorial will work equally well on hexagonal grids.
Mouse over a hex in the diagram to see the path to it. Click or drag to toggle walls.
Neighbors. The sample code I provide in the pathfinding tutorial calls graph.neighbors to get the neighbors of a location. Use the function in the neighbors section for this. Filter out the neighbors that are impassable.
Heuristic. The sample code for A* uses a heuristic function that gives a distance between two locations. Use the distance formula, scaled to match the movement costs. For example if your movement cost is 5 per hex, then multiply the distance by 5.
More#
I have an guide to implementing your own hex grid library, including sample code in C++, Java, C#, Javascript, Haxe, and Python.

The best early guide I saw to the axial coordinate system was Clark Verbrugge's guide, written in 1996.
The first time I saw the cube coordinate system was from Charles Fu's posting to rec.games.programmer in 1994.
DevMag has a nice visual overview of hex math including how to represent areas such as half-planes, triangles, and quadrangles. There's a PDF version here that goes into more detail. Highly recommended! The GameLogic Grids library implements these and many other grid types in Unity.
In my Guide to Grids, I cover axial coordinate systems to address square, triangle, and hexagon sides and corners, and algorithms for the relationships among tiles, sides, and corners. I also show how square and hex grids are related.
James McNeill has a nice visual explanation of grid transformations.
Overview of hex coordinate types: staggered (offset), interlaced, 3d (cube), and trapezoidal (axial).
The Rot.js library has a list of hex coordinate systems: non-orthogonal (axial), odd shift (offset), double width (interlaced), cube.
Range for cube coordinates: given a distance, which hexagons are that distance from the given one?
Distances on hex grids using cube coordinates, and reasons to use cube coordinates instead of offset.
This guide explains the basics of measuring and drawing hexagons, using an offset grid.
Convert cube hex coordinates to pixel coordinates.
This thread explains how to generate rings.
The HexPart system uses both hexes and rectangles to make some of the algorithms easier to work with.
Are there pros and cons of “pointy topped” and “flat topped” hexagons?
Line of sight in a hex grid with offset coordinates, splitting hexes into triangles
Hexnet explains how the correspondence between hexagons and cubes goes much deeper than what I described on this page, generalizing to higher dimensions.
I used the PDF hex grids from this page while working out some of the algorithms.
Generalized Balanced Ternary for hex coordinates seems interesting; I haven't studied it.
Hexagonal Image Processing (DOI) is an entire book that uses a hierarchical hexagonal coordinate system.
Hex-Grid Utilities is a C# library for hex grid math, with neighbors, grids, range finding, path finding, field of view. Open source, MIT license.
This is the oldest reference I can find for axial grids: Luczak, E. and Rosenfeld, A., Distance on a Hexagonal Grid. IEEE Transactions on Computers (1976) (DOI) It calls the axial system oblique coordinates and the offset systems pseudohexagonal grids.
Snyder, Qi, Sander's paper Coordinate system for hexagonal pixels (DOI) describes gradients, diffusion, and map storage for axial coordinates. Mersereau's paper The processing of hexagonally sampled two-dimensional signals (DOI) describes signal processing on axial coordinates.
There's a paper that calls cube coordinates *R3 coordinates: Her, I., Geometric transformations on the hexagonal grid, IEEE Transactions on Image Processing (1995) (DOI) It covers coordinates, correspondence to cube coordinates, rounding, reflections, scaling, shearing, and rotation. A paper from the same author (DOI) covers distances.
The Reddit discussion and Hacker News discussion and MetaFilter discussion have more comments and links.
The code that powers this page is partially procedurally generated! The core algorithms are in lib.js, generated from my guide to implementation. There are a few more algorithms in hex-algorithms.js. The interactive diagrams are in diagrams.js and index.js, using Vue.js to inject into the templates in index.bxml (xhtml I feed into a preprocessor).

There are more things I want to do for this guide. I'm keeping a list on Trello. Do you have suggestions for things to change or add? Comment below.

Email me at redblobgames@gmail.com, or tweet to @redblobgames, or post a public comment:

Load comments
Copyright © 2019 Red Blob Games
 Created 11 Mar 2013 with Haxe and D3.js ; updated in 2018 to use Vue.js ;  Last modified: 06 May 2019